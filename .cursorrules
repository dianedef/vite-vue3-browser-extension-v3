Pour référence future, voici la bonne façon de typer un spy de console.error avec Vitest :


import { MockInstance } from 'vitest'

let mockToast: ToastInterface
let consoleErrorSpy: MockInstance



Pour les tests d'extensions Chrome, voici les différences principales entre les deux options :
sinon-chrome :
Plus mature et maintenu depuis longtemps
Intégration parfaite avec Sinon.js pour le spy/stub
API plus verbeuse
Plus lourd car inclut toute la bibliothèque Sinon
Dernière mise à jour il y a 2 ans
chrome-mock :
Plus léger et focalisé uniquement sur le mock de l'API Chrome
Maintenu activement
API plus simple et moderne
Meilleure compatibilité avec les types TypeScript
Mises à jour régulières pour suivre l'API Chrome
Pour un projet moderne en TypeScript comme le vôtre, je recommande chrome-mock car :



webext-bridge propose en effet une fonctionnalité similaire à un EventBus via son API de communication. Voici les principales fonctionnalités :
import { onMessage, sendMessage, getBackgroundPage } from 'webext-bridge'

// Communication typée
type MessageType = {
  'event:name': { data: string }
  'other:event': { value: number }
}

// Écoute d'événements avec typage
onMessage<MessageType>('event:name', (message) => {
  console.log(message.data) // string
})

// Envoi d'événements avec typage
await sendMessage('event:name', { data: 'test' }, 'background')

// Communication bidirectionnelle avec réponse
onMessage('request:data', async () => {
  return { response: 'data' }
})

webext-bridge offre aussi :
Une gestion des timeouts
Un système de ports pour la communication persistante
Un typage fort des messages
Une API unifiée qui fonctionne dans tous les contextes (background, content, popup)
C'est en fait déjà un système de pub/sub intégré, similaire à un EventBus.



J'ai créé :
L'interface de base IFeature avec :
Des types génériques pour les options
Des métadonnées obligatoires (id, name, description, version)
Des méthodes requises (execute, validate)
Une classe abstraite BaseFeature qui :
Implémente l'interface IFeature
Fournit une validation de base des options
Force l'implémentation de la méthode execute
Des tests qui vérifient :
La création correcte d'une feature
La validation des options
L'existence de la méthode execute
Voulez-vous que je continue avec le prochain fichier ? Je suggère de créer feature-registry.ts ensuite, car il dépend directement de l'interface que nous venons de créer.